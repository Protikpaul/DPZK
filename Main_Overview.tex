In the single-prover setting, the efficiency of a zero-knowledge protocol is usually measured in terms of: 
\begin{itemize}
	\item {\em prover complexity}, denoted by $t_\prover$, which represents the time complexity of the prover algorithm,
	\item {\em proof/argument size}, denoted by $\zkcomm$ that refers to the amount of communication from the prover to the verifier,
	\item {\em verifier complexity}, denoted by $t_\verifier$, which represents the time complexity of the verifier algorithm, and
	\item {\em round complexity}, denoted as $\zkrounds$, which represents rounds of interaction between the prover and the verifier. %especially when a non-interactive prover is obtained from its interactive version in a provably secure manner \cite{BCS16}.
\end{itemize} 
However, these parameters do not capture the core bottleneck in the setting of multiple provers.
%For instance, Spartan \cite{spartan} has an $O(N \log N)$ \commentA{unclear; you mean no. of multiplication or overall arithmetic operations? } proof generation algorithm, but due to the high multiplicative complexity of proof generation its straightforward distributed version requires $O(N^2)$ MPC multiplications where $N$ is the number of gates in the circuit representation of the predicate being proved.  \commentA{intuitively explain why the jump from $NlogN$ to $N^2$ happens}%Similar arguments will be made in a future section for the other state-of-art protocols like Aurora \cite{aurora}, Bulletproofs \cite{bulletproofs}. \dnote{mention the asymptotics in the above claims}
As a first step in our work, we identify additional parameters with significant impact in a distributed proof generation. A lower value of each parameter enhances the practicality of the distributed protocol.

\noindent\textit{Proof-generation communication ($\prcomm$)}:
%The first parameter of interest is \textit{proof generation communication} $(\prcomm)$. 
This parameter quantifies the amount of communication between the provers during the distributed proof generation. 
This is meant to capture additional MPC communication that provers would incur while computing the messages to the verifier. 
Using secret-sharing based MPC protocols, ~\cite{GMW87, BGW88, SPDZ}, this depends on the number of multiplications between inputs 
from different parties ({\em cross-multiplications}) that need to be performed to compute the messages to the verifier. 
%\nnote{Don't we need to motivate why this parameter is important ?}
%In general, this grows linearly with the circuit complexity of the proof generation algorithm for the practical MPC protocols. 
%\nnote{Why are we discussing circuit complexity of proof generation algorithm?}
%\dnote{I am saying "practical" because there are RAM based protocols which do better than circuit complexity of the algorithm.}
%But, there also exist MPC protocols, the secret-sharing based MPC protocols \cite{GMW87, BGW88, SPDZ}, where the communication is only dependent on the number of cross-multiplications i.e., the multiplications between the witness bits from different parties. %This parameter \textit{circuit share complexity}, which we will explain later, will be relevant in many real-world applications. 

%\commentA{section 1.2 should be here, circuit share complexity is related to cross multiplications which is what you talk above. in its current location, it is not clear if it is another parameter of DPZK. If it is, it should be part of this section. To me, it looks like a parameter that impacts both proof generation and proof generation rounds. So after explaining both this parameters, say that we identify a common parameter called 'circuit share complexity' that impacts both in bla bla way. But the above four parameters will be the ones we use for stating the complexity of our protocols and for the purpose of comparison  }
%, since an affine function over the witnesses and a multiplication between witness bits from the same prover can be computed without any interaction in a secret-sharing based MPC.

\noindent\textit{Proof generation rounds ($\prrounds$)}:
%The next parameter of interest is the number of \textit{proof generation rounds ($\prrounds$)} which 
This indicates the number of MPC executions between the provers during the distributed proof generation. 
\commentA{the prior and the next sentences are same. please combine. it is not clear why the rounds inside MPC is not counted. or that what you mean? these descriptions are very confusing } 
%Informally, it denotes the number of MPC protocols the provers need to invoke. %separate MPCs that the provers have to run throughout the proof generation process, times the number of interactions needed inside each 
 This is orthogonal to $\zkrounds$ and may not have any correlation with it. % Note that this could be lower than the round complexity of the zero knowledge protocol. 
%\nnote{Do we really need the discussion below? What is the conclusion?}
%{\color{blue} In a typical MPC, this parameter would be a constant number for
%the garbled-circuit based protocols and be the cross-multiplicative depth of the
%circuit for the secret-sharing based protocols. But in our setting of
%distributed proof generation, the provers have to compute their message for that
%round, in clear, to be sent to the verifier. Thus, even a garbled-circuit based
%approach here might result in $\prrounds$ be linear in the number of
%$\zkrounds$, and hence not a constant with respect to the size of the instance
%unless $\zkrounds$ is also a constant.} 
%\commentA{it's hard to digest the above; what's the point you are trying to make; some of the zkRounds do not need MPC and hence we can get read of the linear independence of prRounds from zkRounds?  }
%\dnote{The above point makes sense only for the interactive version. Should we also argue for non-interactive proof generation?-that it requires us to do hash inside MPC if MPC is not done for each step.} 
%\commentA{I didn't understand your comment. other can help?}
\commentN{Is it necessary to state the point below? It's a bit vague. And if the MPC protocols are proven UC-secure, then I think sequential composition  
is fine. Can the complexity of a security proof be a parameter of interest?}
The parameter $\prrounds$ is also of cryptographic interest. If there are more than one round of prover message generation that requires MPC, care has to be taken to ensure a secure composition of the individual MPCs to prove the complete protocol is secure.

\noindent\textit{Shared circuit complexity}:
We will now elaborate a bit more on the number of cross-multiplications in the circuit that needs to be evaluated distributedly for proof generation since
that is of practical relevance and influences prover communication ($\prcomm$)
and proof generation rounds ($\prrounds$). In applications where the initial witness is canonically \textit{partitioned} among the provers, \UPDATED{that is the witness $\wit = \wit_1||\ldots||\wit_{\Num}$,} the term \textit{shared circuit} denotes a sub-circuit consisting of wires, whose values are functions of inputs from more than one prover. 
\commentN{Replacing the desciption with new application}
{\color{brown}
Consider the earlier example of a trade-logistics business network, now on top of a blockchain where the hashes (or any other commitment) of a large number of data points from different participants are stored. 
When parties come together to prove a statistic on their combined data, they
need to establish that each data point used to compute the statistic corresponds to a 
hash entry in the blockchain and the correctness of the result of the statistic computation on these data points. Nevertheless, the values of the circuit wires connecting each data point to its respective hash depend only on witness bits from a single party that owns the data point. Only the part of the circuit computing the statistic takes witness bits from multiple parties, and thus only this part needs to be considered for MPC while computing shares of extended witness. It would be desirable, though not evident, that the complexity of the MPC for {\em proof
	generation} also depends favorably on the size of the shared circuit. 
}
{\color{blue}
Consider the circuit for proving validity of the {\bf Bid} transaction in Section \ref{sec:application2}. We assume that $\mathsf{rt}$ denotes the Merkle
 root over the list $\mathsf{CmList}$ of coins. Thus, to show that a coin commitment $\mathsf{cm}\in \mathsf{CmList}$, one provides an authentication path 
 $\bm{p}$ from $\mathsf{cm}$ to $\mathsf{rt}$. Thus, to show that coin corresponding to each serial number
$\mathsf{sn}_i\in \bm{s}$ appears in the list $\mathsf{CmList}$, the witness $\bm{w}_i$ involves the coin commitment $\mathsf{cm}_i$, the trapdoor $\tau_i$ for the coin 
and authentication path $\bm{p}_i$ from $\mathsf{cm}_i$ to the root $\mathsf{rt}$. This part of the witness is completely known to the owner of 
the $i^{th}$ coin. Thus the witness $\bm{w}$ authenticating the coins against the serial numbers is canonically partitioned into $\bm{w}_1,\ldots,\bm{w}_n$
and requires no interaction to compute. On the other hand, secure computation is required to compute shares of witness wires evaluating the comparison
$V==v$ where $V=v_1+\cdots+v_n$ denotes the cumulative value of the coins and $v$ denotes the public bid value. Clearly, this ``shared circuit'' 
constitutes only a fraction of the entire witness. It would be desirable, though not obvious if the secure computation for {\em computing the proof} 
also depends on the size of {\em shared circuit} instead of the that of the entire circuit. Since verifying merkle authentication paths using 
standard hash functions (like SHA2) incur upwards of $100K$ gates, the practicality of distributed proof generation in this case will be
greatly improved if its parameters (like $\prcomm$ and $\prrounds$) are 
linear in the size of the shared circuit $N_s$ and not the total circuit size $N$.
%Looking ahead, the complexity of the interaction between the provers in our DPZK protocol will be linear only in the circuit share complexity of the circuit predicate to be proven, and not in the total size of the circuit. 
}

In summary, the efficiency of a $\DPZK$ in the public-verifiable and
non-interactive setting (which is our concern) will be measured via $\prcomm$,
$\prrounds$, in addition to the parameters for the single prover protocol.

\subsection{On the formal Definition of $\DPZK$}
%\commentA{changed the title of this subsection and the text below sightly} 
%The primary departures that the security definition of $\DPZK$ witness compared to the  traditional single-prover ZK are concerning the zero-knowledge property.     
%Before we delve into our DPZK construction, we would also provide a couple of subtle notes regarding the zero-knowledge property of DPZK protocols. This would shed some light on the rationale for some of the artefacts of DPZK protocols. 
%In an $\DPZK$ protocol, the verifier is allowed to collude with a subset of provers to learn the witnesses of the other provers. A strong definition of zero-knowledge should ensure that this collusion does not learn any additional information than what they know before the protocol. %Here, one should also consider the number of other provers involved in the proof generation as an additional information. In our protocols, we will allow all the provers to know the total number of provers involved. This will lead to a relaxed definition where a verifier colluding with a prover will additionally learn the total number of provers\pnote{usage of broadcast reveals the number of provers even without collusion}. This still does not let a standalone verifier learn the total number of provers during its interaction with the provers.

%\commentA{I am not finding the following paragraph pressing. Should we remove? }\dnote{This is to emphasize the need for public key ops or communication in oracle generation/answering too. I cut it short though.}
%This subtle note also impacts the size of the oracles for the protocols in the IOP framework \cite{aurora, ligero}. The oracle and the answers to the oracle queries should be independent of the total number of provers. Hence, for the IOP-based protocols, the efficiency parameters discussed above should be optimized not only for the prover message generation but also for the oracle generation and the query answering.\footnote{In principle, generating the oracle or answering a query would form a part of the prover message generation when IOP is viewed in the lens of an arbitrary interactive protocol.}
%The IOP-based protocols in the literature \cite{aurora, ligero} market their non-use of public-key cryptography and thus a potential post-quantum security feature. To achieve zero-knowledge in the distributed prover setting while retaining these features, at a high level, they have to incur the additional overhead in $\prcomm$ due to using information-theoretic MPC to also construct the oracle and answer oracle queries. 

%Another subtle point here is that a single-prover ZK protocol provides the zero-knowledge property only for honest provers. The witness is not guaranteed to be hidden from the verifier if a prover deviates from the protocol. Hence, in a distributed prover setting it is non-trivial to prove or even define the zero-knowledge property if some of the provers deviate from the protocol or if they do not have the valid witness. 

Just like the efficiency considerations, the security definition for a $\DPZK$ protocol needs to account for additional interaction. 
In particular, the security definition needs to capture the fact that interaction among the provers to generate the proof does not 
leak knowledge about their respective witnesses to other provers. 
We come up with an MPC-style definition based on real-world ideal world paradigm \cite{Canetti00,Goldreich2001,Lindell17,CohenL14}  
that takes the above issues into account. In the ideal-world, the provers deliver their respective part of the witnesses, 
and the functionality (that is parametrized with a language) combines them and check the assertion of a statement. 
In the real protocol, the provers participate in instances of MPC for `proof-generating functions' to generate messages for the verifier. 
To keep the proof-size independent of the number of provers, one of the provers enacts in a special role called 
aggregator that prepares the message for the verifier, taking into account communication from all its fellow provers 
and communicates the same to the verifier on behalf of all the provers. We say our protocol is secure if whatever an 
adversary (corrupting various subsets of provers and verifier) can do in real execution can be done in the ideal execution. 
\commentN{Suggestion: Let's just highlight important assumptions and leave the rest to Section 4. Too much repetition and rambling below}
{\color{brown}
Lastly, keeping in mind the final goal of non-interactive and publicly-verifiable proofs/arguments, 
we explicitly mention the exact corruption scenario that we handle for our constructions.  
For example, it is enough to tackle a semi-honestly corrupt verifier (since a non-interactive proof does not 
give any additional scope of misbehaviour to a maliciously corrupt verifier over a semi-honestly corrupt one).  
We refer to Section~\ref{sec:security model} for complete details. 
\commentA{this sentence is totally out of   context. The entire green text is on distributed prover. what do you really mean?}%Next, we move on to discuss the single-prover construction on which we build our $\DPZK$. 
We assume that \commentA{if you are talking about a single-prover, then why do you say provers?} 
provers do not deviate from the protocol. However, our protocol can withstand the scenario if all the provers are maliciously 
corrupt together due to the soundness property of the underlying ZK protocol. By using known techniques from malicious secure MPC, 
security against malicious provers can be achieved though the overhead is significant. 

{\color{blue}
We formalize the security of a $\dpzk$ protocol and state the precise trust assumptions under which we realize it in Section \ref{sec:security model}.
Here we foreshadow the important aspects: (i) {\em Witness Confidentiality}, i.e, a DPZK protocol ensures that other provers do not learn private inputs of a prover during 
distributed proof generation involving {\em semi-honest} provers, 
(ii) {\em Zero Knowledge}, i.e, an honest verifier learns nothing beyond the truth of the statement 
in a DPZK protocol involving semi-honest provers and (iii) {\em Soundness With Witness Extraction}, i.e, an honest verifier rejects a false statement even if the provers act maliciously.
In practice, the restriction of honest verifier is overcome by using standard transformations to obtain non-interactive 
argument from the interactive proof. Realizing a DPZK protocol for a malicious set of provers in an interesting future work.
}

% Also, we will discuss how can we achieve security against maliciously corrupt provers (assuming the aggregator \commentA{we have not introduced aggregator} to be semi-honest). hide the number of provers from a corrupt verifier and to
\subsection{Compiler for IOP-based proof systems}
\ADDED{Several recent constructions of efficient SNARKs~\cite{aurora, BCS16} are modeled in terms of {\em Interactive Oracle Proofs} (IOPs). In this work, we present a compiler that compiles an existing IOP, into an IOP
that admits efficient proof generation by a distributed set of provers. This requires navigating several technical challenges: (i) IOPs use the abstraction of oracles, wherein the verifier does not receive the messages from the prover entirely, and only query a small number of positions and
(ii) transforming IOPs to {\em Non-interactive Proof of Knowledge} (SNARKs) requires the use of
collision-resistant hash functions to realize the oracles. The major challenge that we address is providing the abstraction of oracle by a distributed set of provers (with shares of the message), which is indistinguishable from the one provided by a single prover (with the complete message). }

\ADDED{We use a common aggregator $\Ag$ to interact with the verifier on behalf of all the provers. Naively, to provide oracle access to a message, $\Ag$ itself needs to have access to the complete message. But this violates our privacy constraints: IOPs ensure privacy only when a ``small'' portion of the message is accessible. We resolve this \UPDATED{conflict} by using linear sharing and homomorphic commitments. In all rounds, provers maintain a linear sharing of the IOP message. They share commitments of their shares with $\Ag$, which then has access to the commitment of complete IOP message. To the external verifier, $\Ag$ presents the commitment as the message and provides query access to it. While answering queries on the ``committed oracle'', $\Ag$ additionally opens the commitments that are queried. We present the above construction as two steps: the first step involves transforming an existing IOP into an IOP with ``homomorphic'' oracles. In the second step, a $(\Num + 1)$-$\DPZK$ protocol is obtained where $\Num$ provers run the prover algorithm of the homomorphic IOP protocol ($\Num+1$ indicates that the protocol involves $\Num$ provers and one verifier). These provers jointly compute the proof where the provers start with a linear sharing of the witness.  We elaborate more below and defer the details to the later section (Section~\ref{sec:compiler}).}
%------------------------

%In this work, we present a compiler for general IOP-based proof systems to support DPZK. Suppose one wishes to use an IOP-based proof system in the distributed prover setting. In that case, it encounters the following challenges: If each of the provers set their oracles individually and the oracle responses are conveyed either via a common aggregator $\Ag$ or responses are given directly towards the verifier. In both cases, proof size and verification time increase proportionally with the number of provers. On the other hand, if each prover sends its complete message (considering the message to be a linear function of the witness, if not use MPC to obtain a linear sharing) to $\Ag$, then $\Ag$ combines the message to set the oracle for the verifier. In this approach, $\Ag$ can break the privacy of an honest prover. Therefore we need a mechanism that allows $\Ag$ to combine the messages of each prover while not knowing the underlying messages.
%Furthermore, it is also required that once a prover sets its messages, it should not be able to deviate from the same. These two criteria can be obtained using homomorphic commitments. Note that the homomorphic property of the commitment scheme allows an aggregator to perform a ``combine'' operation on the committed values while the hiding property ensures privacy. At the same time, the binding property guarantees that a prover once commits to a message cannot deviate at a later point.

%In the construction of our compiler, we start with an IOP-based protocol. In the first step, we obtain a new IOP-based protocol using a homomorphic commitment scheme, instantiated using Pedersen commitment. Then we describe how to obtain an efficient DPZK proof system from the compiled proof system.

\ADDED{Let $\innp{\prover}{\verifier}$ be an $r$ round IOP-based proof system. $\prover$ sends $f_i = (m_i, \pi_i)$ as the $i$th round message and $\verifier$ has oracle access to $f_i$ where $m_i$ is given to $\verifier$ in the clear and $\verifier$ makes bounded number of queries to $\pi_i$. In the compiled protocol, say $\innp{\prover'}{\verifier'}$, $\prover'$ sends $f'_i = (m_i, \pi'_i)$ at the $i$th round where $\pi'_i$ is the commitment of $\pi_i$. In this step a homomorphic commitment is used. If $\verifier'$ queries some location to the oracle, oracle sends the committed value, and $\prover'$ provides the corresponding opening. $\verifier'$ checks if the opening of $\pi'_i$ on the queried locations are correct. If all the openings are correct then $\verifier'$ runs the verification algorithm of $\verifier$. Completeness and zero-knowledge of the newly obtained protocol follow directly from the underlying protocol, and soundness depends on the soundness property of the base protocol and the binding property of the commitment scheme.}

\ADDED{To obtain the DPZK from the compiled protocol, we start with $\Num$ copies of $\prover'$. Each of these provers computes a linear sharing of $(m_i, \pi_i)$. If the $m_i$ and $\pi_i$ are linear functions of the secret, then no interaction among the provers is required. That is, they locally compute these shares. If not, they perform secure evaluations of these values and obtain linear shares. All the provers locally obtain sharing of $(m_i, \pi'_i)$ from linear sharing of $(m_i,\pi_i)$. $\Ag$ obtains shares of $(m_i, \pi'_i)$, combines them, and sets them as the oracle. The verification algorithm is the same as in the single prover protocol.} 

\ADDED{This compiler preserves the proof size and the number of the rounds. However, the compiled protocol has an overhead of proof generation and verification time. This overhead depends on the oracle size, the number of oracles and the number of rounds. %In Section~\ref{sec:compiler}, we discuss this in more detail.
}


\subsection{Instantiations of distributed prover zero-knowledge}
\ADDED{We instantiate a few distributed proof generation protocols. As discussed earlier, a protocol obtained from the above compiler is more likely to perform better in a distributed proof generation if the base protocol has less number of rounds and oracles. Thus we start with the compiled version of Ligero~\cite{ligero} since it has a constant number of rounds and only one oracle. Further, we provide a protocol $\name$ by optimizing this newly obtained protocol from Ligero.}

\ADDED{Additionally, we discuss the cost of the distributed protocol obtained from Aurora~\cite{aurora}. This gives a perspective of the efficiency of a compiled protocol where the base protocol is a multi-oracle IOP.
We study the distributed proof generation for non-IOP protocols such as Bulletproofs~\cite{bulletproofs} and Spartan~\cite{spartan}. Bulletproofs achieve the distributed proof generation naturally without requiring any additional primitives excluding secure multiplication (which is inherent in all the instantiations).   In the distributed variant of Bulletproofs, provers securely evaluate multiplication of $2$ vectors. The size of these vectors is $O(N_s)$, where $N_s$ is the size of the shared circuit. Furthermore, each prover sends $O(N)$ field elements towards the aggregator. In the distributed version of Spartan, $O(N^2)$ multiplications are required among the provers. However, this construction does not ensure privacy among the provers. This shows the non-triviality of the distributed proof generation. }
 

\subsection{\name{}: an MPC-friendly zero-knowledge protocol}
\CHANGED{To construct $\name$, we adjoin an additional dimension in the Ligero protocol and modify the encoding, the linear check, and the quadratic check accordingly. With this optimization, we break the $\sqrt{N}$ ($N$ is the size of the circuit) barrier of Ligero, following a similar idea of the concurrent work of Ligero++~\cite{ligero++} where succinct inner product argument is used. Ligero++ uses inner product argument from Virgo~\cite{Virgo} whereas, we use Bulletproofs'~\cite{bulletproofs} inner product argument. Furthermore, for the soundness of $\name$, we provide novel results in coding theory. By adjoining an additional dimension, our protocol gets better flexibility to trade-off between proof size and verification time. Furthermore, we organize the witness so that if the shared circuit is small, then the communication among the provers is required for $N^{1-2/c}$ multiplications. In contrast, Ligero's compiled protocol would require $N^{1/2}$ multiplications. Also in distributed version of Ligero and $\name$, each prover sends $O(\sqrt{N})$ and $O(N^{1-2/c})$ field elements towards the aggregator respectively. Note that the 3-D encoding, obtained by adjoining an additional dimension, helps in reducing the proof size while keeping the verification time low. Also, if the size of the shared circuit is small, this additional dimension aids in reducing the communication among the provers as well. The details of $\name$ are given in Appendix~\ref{app:grapehene_securityproofs}.}
%We present an MPC-friendly single-prover protocol \name{} with a transparent setup which
%allows an efficient $\DPZK$.
%%This linear $\prComm$ is due to linear number of cross-multiplications which can be done concurrently, and hence the MPC is only performed on an $N$ mult-gates circuit of depth 1. 
%\name{} achieves proof size and verification complexity competitive with the
%state-of-art zero knowledge protocols, while achieving efficient distributed
%proof generation. In particular, for a statement represented as a circuit with $N$ multiplication gates,
%\name{} admits a proof size of $O(N^{1/c})$ for
%arbitrary $c\geq 2$, with a verification complexity of $O(N^{1-2/c})$ public key
%operations and $O(N)$ field operations. \name{} is a public-coin, honest verifier
%zero-knowledge protocol in the Interactive PCP (IPCP) \cite{KR08, KR09, GIMS10,ligero}
%paradigm. In IPCP paradigm, the verifier reads a small number of bits from PCP created by the prover and exchanges a small number of bits with the prover.
%There is a known transformation that converts ZK designed with IPCP to an interactive ZK via collision-resistant hash functions \cite{IshaiMS12, IshaiW14} which in turn can be made non-interactive  \cite{FS86, BCS16}. 
%
%% that achieves the property of zero-knowledge-with-collusion i.e.,
%%the witnesses from a set of provers are not revealed to a verifier even when it
%%colludes with the complimentary set of provers who are honest-but-curious.
%
%%Efficiency Desiderata:  
%%- Transparent setup 
%%- Minimum interaction between the provers (\# of rounds of MPC) 
%%- Total communication complexity of the msgs exchanged
%%- verifiers view is indistinguishable from a single prover setting
%%- How efficient is underlying zkp protocol (public key operations, size of proof, prover/ verification time)
%%- Applicability to a general class of computation
%
%%\paragraph{Technical overview}
%%Our goal is construct a zero-knowledge protocol which optimizes all the efficiency parameters: $\zkcomm$ a.k.a., the proof size, $\zkrounds$, provers' complexity (represented by $\prcomm$ and $\prrounds$) and the verifier's complexity. We will now brief the MPC (non-)friendliness of the state-of-art protocols in the setting before we brief \name{}.
%%
%%Also, its verifier requires $O(N)$ public key operations to verify a proof. 
%%Spartan \cite{spartan} admits sublinear verifier complexity in an amortized sense, but its prover again incurs $O(N^2)$ multiplications.
%
%\name{} follows the broad outline of Ligero~\cite{ligero}: 
%(i) encoding the `extended' witness via a suitable error-correcting code, where the extended witness is the concatenation of the wire values of the circuit (for the statement) in a topological order evaluated on the witness, (ii) using the
%encoding to check linear and quadratic relations on the extended
%witness, and (iii) a check to ensure that the extended witness is correctly
%encoded. The extended witness (henceforth witness) encoding is committed as an ``oracle'' and is queried
%during the linear and quadratic checks.  Our key innovations are
%listed below. 
%
%\noindent\textit{New encoding and oracle}: A core technical contribution of our
%work is a novel way to encode the witness and design the three checks in
%the zero-knowledge protocol around the new encoding. The \textit{witness} is
%represented as a \textit{3D matrix} of dimensions $p \times m \times s$ whose
%product is $O(N)$. The \textit{witness encoding} is obtained by encoding every
%$m \times s$ `slice' of the 3D matrix using a carefully selected product of
%Reed-Solomon codes.  The \textit{oracle} is now obtained by committing each $O(m)$-sized `column' in 
%the encoded witness using homomorphic vector commitments \cite{Ped92}. 
%This results in an oracle that is a $O(p \cdot s)$-sized matrix of commitments.
%The use of homomorphic vector commitments helps in two aspects: (i) enabling
%distributed proof generation and (ii) achieving proof sizes independent of the
%largest dimension of the matrix. The latter is crucially dependent on the use
%of product codes to achieve soundness with very small {\em query complexity} (the size of the
%oracle revealed to the verifier).
%As we will see later, we will be able to regulate the three dimensions such that both the communication between the provers and the aggregator and that between aggregator and the verifier (argument size) are {\em sub-linear} in circuit-size $N$, while keeping low verification time. Lastly, we present a new coding theoretic result, which appears in Section~\ref{new_result_coding_theory} and proved in Appendix~\ref{app:ProofofLem3dcompression}, and leverage it to prove the soundness of our two stage ``compression'' as explained in the next paragraph. 
%
%\noindent\textit{Checking Linear and Quadratic Relations}: As in other oracle-based protocols~\cite{ligero,aurora}, checking the linear and quadratic relations on the witness reduces to 
% checking identities on the polynomials derived from polynomials encoding the witness. 
%To ensure that the size of the final polynomial, which can be shared with the verifier is
%proportional to the smallest dimension of the three dimensional witness matrix,
%we need to achieve two stages of ``compression''. To ensure soundness for both
%stages of compression, we introduce an intermediate structure (a two dimensional
%matrix) to which the prover commits. This intermediate matrix enforces
%consistency between the three dimensional encoding, and one dimensional
%polynomial message to the verifier as it can be checked to be consistent with
%both. Having an extra dimension (over Ligero) also allows us to shave off the size of the
%largest dimension over which we run (expensive) inner-product arguments. This
%allows us to achieve inner-products over vectors of size $N^{1-2/c}$, which
%makes our verifier quite efficient despite using public key operations. %These protocols appear in Section~\ref{sec:graphene}.
%
%
%\subsection{\dpname: A new $\DPZK$ protocol}
%%\commentA{The structure of this section should be as follows:  (a) state what the extract result for $\DPZK$, mentioning the achieved complexities (can plug in the best-known MPC)  (b) tell the high level idea for the approach taken. be concise (c) tell about the difficulties in turning existing spzks to DPZK (d) compare and put the table with asymptotic complexity; (e) report some  of the numbers that we obtain from benchmarking.  }
%Building on \name{}, we design our $\DPZK$ protocol \dpname{} with  $\prcomm$ linear in size of the $\NP$ verification circuit for the language and with a constant $\prrounds$. To be more precise, the communication for a
%$\Num$-prover proof generation for an $N$-multiplication gate circuit 
%would be $O(\Num^2\cdot \max(N_s, N^{1-2/c}) + \Num \cdot N^{1-2/c})$, where
%$N_s$ is the shared circuit size as introduced in Section~\ref{sec:efficiencyparams}. Moreover, although $\zkrounds$ is $O(\log{N})$, $\prrounds$ is constant, limited to a single instance of secret-sharing based MPC on a circuit
%of size $\max(N_s,N^{1-2/c})$ and multiplicative depth as $1$. Here we can see another benefit of viewing the witness as a 3 dimensional matrix. The largest dimension can be picked in such a way that, it can cover the complete shared circuit $(N_s)$ if the shared circuit is not too big, which is true in many applications. To emphasize the non-trivial properties attained by our protocol, we discuss the roadblocks in naively adapting existing state-of-art zero-knowledge protocols to the distributed prover setting.\smallskip
%
%\noindent{\em Roadblocks in achieving $\DPZK$}: Intuitively, to satisfy the desiderata
%of distributed proof generation with minimal prover communication, large parts
%of the messages to the verifier must be computable {\em locally} by the provers
%using their respective shares of the witness, which then must be efficiently 
%aggregatable later to obtain the final message. Thus, the prover messages must have some
%``homomorphic'' properties with respect to the witness. This requirement
%precludes naively extending recent efficient zero-knowledge protocols based on
%interactive oracles like \cite{ligero,aurora}. Realizing the oracle while constructing a non-interactive
%argument in the Random Oracle Model (ROM) uses hash functions, which exhibit no such
%homomorphic properties. We address this roadblock in our construction by making
%the oracle homomorphic. However, constructing such an oracle incurs expensive
%public key operations for the prover. For the restricted case of IPCP, where
%only the initial message is an oracle, the additional overhead though
%substantial is tolerable. For more general interactive oracle protocols, such as
%Aurora ~\cite{aurora}, our methods may not be the most efficient. Nevertheless,
%we pose efficient $\DPZK$ construction from general interactive oracle protocols as an
%interesting open question. Even if the messages in the protocol are largely
%homomorphic, small amount of non-homomorphic computation in several rounds 
%would require repeated interaction among the provers. Intuitively, one way to
%avoid repeated prover interaction is to reduce the initial statement, to a
%statement involving ``random witnesses'', which can then be ``handed off'' to the
%aggregator to complete the remaining rounds of interaction with the verifier. It is essential that
%the witnesses in the reduced statement are ``random'' or ``simulatable'' to
%ensure that the aggregator gains no knowledge of provers' witnesses from them.
%In general, in such constructions one must ensure that in addition to verifier's
%view, the aggregator's view also leaks no knowledge. We did not see an obvious
%way to overcome this roadblock for Spartan~\cite{spartan}, without resorting to
%expensive MPC among the provers. Among the existing zero-knowledge protocols, we
%were only able to obtain an efficient $\DPZK$ from Bulletproofs~\cite{bulletproofs} with moderate effort and from Spartan~\cite{spartan} but without privacy guarantee. These constructions appear in Appendix~\ref{app:dpzk_others}
%%{\color{blue} (Put appropriate section)}, 
%and serves as a baseline for
%comparison with $\dpname$. Even for the Bulletproofs based construction, we are
%unable to achieve sub-linear prover communication for a sub-linear shared circuit
%size $N_s$. We extensively compare the two constructions across both the $\DPZK$
%parameters, and the single prover parameters in Section~\ref{sec:performancecompare}.
%  
%Finally, we mention that the provers in \dpname{} are semi-honest in trying to learn 
%each other's witnesses while constructing messages for the verifier. This view
%fits well with the kind of applications we foresee, where incentive to make a
%joint claim is greater than that to deviate from the protocol.
%Even for this weaker adversarial model, proving the security of this
%construction is interesting because of a couple of reasons. The witness shares
%that the provers start with are additive, but they need not be from a secret
%sharing of a ``global'' witness. And, even if the provers' shares are secret
%shares of a global witness with a threshold of $\Num-1$, the aggregator in our
%construction sees messages from \textit{all} the $\Num$ provers. We prove the
%security of \dpname{} taking care of these aspects when the provers and the
%aggregator are semi-honest.
%%\dnote{insert benchmarking numbers for \dpname{}
%%here}
%
%%\footnote{Our DPZK-Bulletproofs construction supporting
%%arbitrary predicates readily follows from their single-prover construction, even
%%though they mention it as an open problem to support arbitrary predicates after
%%they build a distributed proof generation algorithm for range proofs. Our
%%efforts simply distil the multiplicative parts of their inner-product protocol.
%%\pnote{Bulletproofs proof aggregation is not same as distributed proof
%%generation.}} \dnote{is the phrasing in the footnote fine?}
%
%%Each prover in \dpname{} starts with an additive share of the witness. Each prover generates an encoding of its witness using the same procedure as in \name{} due to the additive homomorphism in Reed-Solomon encoding and in oracle generation. \dnote{seems like we have to add slightly more details in the description of \name{} so that we can refer to it here to explain the dpzk construction. @Nitin can you take a shot at this paragraph after you augment the technical overview?}
%
%
%%\subsection*{Distributed proof generation}
%%--- Informal notion of Distributed Provers Zero Knowledge Protocol $\innp{\Pi}{\verifier}$--- 
%%
%%A na\"ive approach to build a $\DPZK$ protocol is to take a single-prover ZK protocol and execute a multi-party computation among the provers of each message to be generated by the prover in the single-prover protocol. This satisfies the required security properties, but suffers in concrete efficiency when MPC is used over the proof generation as a black box. 
%%
%%\subsubsection*{Need for homomorphic commitments} 
%%(Oracle access for IOP).
%%The (non-interactive) zero-knowledge proof generation protocols based on the Interactive oracle proofs (IOP) or the Interactive PCP (IPCP) paradigms make use of \textit{oracles}. The prover establishes an oracle based on her witness. Once established, the IOP/IPCP protocols ensure that a prover will not modify the oracle further in the protocol. The verifier queries the oracle later in the protocol to verify some the claims made by the prover. When IOP/IPCP based proof systems are converted into the non-interactive setting, the establishment of the oracle is done by producing a commitment to the oracle entries.
%%
%%We will now run through a mental experiment on achieving distributed proof generation following the blueprint of the single-prover proof generation algorithm. We desire to not have the proof length depend on the number of parties. As we would discuss in depth later, we would also avoid running an MPC protocol on the proof generation circuit(s) of some zero-knowledge protocol. This would trivially, in theory, satisfy our goals, but it would be very inefficient in practice. The way we satisfy these goals for the establishment of the oracle is by requiring the oracle entries and their commitments satisfy homomorphic properties.
%%\dnote{self: Sounds somewhat weak. Make it more compelling.}
%%
%%\subsection*{Technical summary}
%%We will now provide a high-level summary of our work and along the way mention our core ideas.
%%
%%%Our contributions are two-fold: first in defining and constructing a zero-knowledge protocol with distributed proof generation and the second in proposing the first protocol with (expected) sub-linear verifier complexity.
%%
%%Our main contribution is defining and constructinf a zero-knowledge protocol with distributed proof generation.
%%
%%\paragraph{DPZK}
%%We design a framework for constructing DPZK protocols starting from a single-prover ZK protocol.
%%%To construct our DPZK protocol \name{} we follow the strategy of designing a (public coin honest verifier) single-prover ZK protocol whose proofs are ``aggregatable'' at minimal cost. 
%%Let the parties $\prover_1, \ldots, \prover_{\Num}$ hold their respective witnesses $\wit_1, \ldots, \wit_{\Num}$ to the relation $R(\stmt, (\wit_1, \ldots,\wit_{\Num}))$. 
%%Starting with a (public coin honest verifier) single-prover ZK protocol, there are two steps involved in our proof generation.
%%\begin{itemize}
%%\item The first step involves performing a secret sharing based MPC protocol on $R$ between the provers. As a result, each prover obtains her share of the extended witness, which includes all the wires (correspondingly variables) of a circuit (correspondingly R1CS) representation of R. 
%%\item Next, for each message from the prover to the verifier, the parties perform the following two steps:
%%\begin{itemize}
%%\item The parties run an MPC protocol to obtain their share of the message. This step has a major implication on the efficiency of distributed proof generation. Depending on the single-prover protocol, some messages already posses homomorphism properties. Hence, the output of a local run of the single-prover algorithm for this round on a prover's shares of extended witness is already her share of the message in the distributed proof generation. When the message is not homomorphic, we design custom efficient protocols to obtain the shares of the message.
%%\item One of the prover parties or an external entity trusted with the correctness of execution is chosen as an ``aggregator''. Aggregator is not trusted with the privacy of the inputs. The aggregator receives the shares of the messages from all the parties and performs the steps of the single-prover protocol to be performed with the aggregated message. Also, a prover acting as an aggregator does not have an incentive to deviate from executing the correct protocol during this step. This is because she could have caused the protocol to abort in any of the previous steps, and there is no additional information that she gains in the intermediate steps that aids her deviation in the aggregation step.
%%\end{itemize}
%%\end{itemize}
%%
%%Starting with the single-prover protocol of \cite{ours}, we design custom protocols so that the only additional interaction between the parties during the second step involves MPC for $\intpartofC$ concurrent multiplications, where $\intpartofC$ is the number of wires in the \textit{interactive} part of the circuit. Consider the check $x+y \stackrel{?}{=} z$ when given their respective hashes. If the inputs are present with three different parties, the corresponding circuit for the hash check followed by the addition and equality check involves extensive local computations for the hash before the interaction happens. \dnote{self: Provide a compelling real world use-case here} The additional communication complexity of our $\DPZK$ protocol grows only with the size of the interactive part. To enable this, we do.... start with \cite{ours} --- arrange the rows accordingly in the witness matrix --- 
%%
%%proof size independent of number of parties --- Oracle queries outputs should be independent of the number of parties --- we do it having parties generate a homomorphic oracle starting with their shares on the extended witness --- we would achieve indistinguishability between proof generated in a distributed manner and the proof generated by a single party ---
%%In this, we use homomorphic commitments --- we follow from \cite{ours} --- 
%
%
%%\input{Related_work.tex}
%%Let $P$ be the predicate that is being proved. An aggregation of multiple proofs on the same $P$ produces a proof.  Let us consider the interactive version of the protocol. A proof consists of the messages sent by the prover to the verifier and, additionally in IOPs, the replies to the oracle queries of the verifier.
%%where each message from the prover is first identified whether it is homomorphic or not. If 
%%each prover can produce an additive share of the proof.  find a way to \textit{aggregate} the proof parts from each prover. identify the prover messages which are homomorphic.
%%
%%the goals that we set for our construction
%%
%%the theme that we will have - require every message from prover to verifier be homomorphic.
%%
%%concrete starting point - ligero --- 
\subsection{Related Work}\label{sec:relatedwork}
%\commentA{this section does not look comprehensive}
As mentioned earlier in the introduction, Pedersen \cite{Ped92} defines the
notion of distributed proof generation and proposes a generic construction using
MPC. Over the years, works have discussed distributed proof generation for a
restricted class of predicates: Desmedt et al. \cite{DDB94} proposing proofs for
graph isomorphism, various works \cite{King05, DDS, Desmedt2011} for proposing
threshold signatures, Keller et al. \cite{EfficientTZ} for a class of sigma
protocols. 
{\color{blue} More recently \cite{bulletproofs} presented a distributed variant of {\em range proofs} which allows
several provers to compute a common proof showing their private inputs lie within an interval. However their protocol
does not satisfy our stronger privacy requirements as the size of the proof depends on the number of provers.}

{\color{brown} Bulletproofs' \commentA{not sure if the "`" is used correctly. check}~\cite{bulletproofs} rangeproof provides a 
property that allows multiple proofs to be aggregated even if the provers are different.  
\commentA{something wrong with this sentence. please correct}
However, it does not work in our setting, that is, if the witness is held by multiple provers and jointly they generate the proof, 
whereas in bulletproofs, each provers must know the witness corresponding to its statement.}
%presents a ``distributed'' protocol to produce an aggregation of range proofs on inputs held by different parties. However, their completeness property is weaker than ours, i.e, a set of provers with valid witness can prove the statement only if each input gate is exclusively known to one prover. 
Trinocchio \cite{trinocchio} proposes a distributed proof generation method for
Pinocchio  \cite{pinnochio_PHGR} but only for honest majority and semi-honest\commentN{so do we, right?} setting. Moreover, it needs the trusted setup
model. 
\UPDATED{The work DIZK \cite{dizk} provides a distributed implementation of proof generation to provide better prover time. In other words, it parallelizes provers work. Thus, there is no notion of privacy among the provers in this setting.}
%	a distributed implementation of the proof generation of a non-interactive zero-knowledge protocol (zkSNARK). 

\ADDED{In this work, we study how to achieve distributed proof generation from other existing works such as Ligero~\cite{ligero}, Aurora~\cite{aurora}, Bulletproofs~\cite{bulletproofs}, Spartan~\cite{spartan} and the corresponding challenges. To attain an efficient construction, we start with a Ligero-style protocol and use a similar approach to~\cite{bootle2020linear, bootle2020zero}, where the witness is viewed as a multi-dimensional matrix. However, we restrict to 3 dimensions since, among these dimensions, only the smallest one contributes to the proof size, while the remaining two aid in better verification time. In our setting, increasing the number of dimensions beyond three leads to more complicated and costlier proof-generation and verification protocols without improving any other parameters. \cite{bootle2020zero} provides linear-time prover with poly-logarithmic verification, but a significant drawback of this work is that the soundness error is $O(1)$. Furthermore,~\cite{bootle2020linear} obtain linear-time prover by using linear-time encodable codes. For this, they use a linear code provided by~\cite{druk2014linear}, whose decoding is conjectured intractable. Due to this property, ~\cite{bootle2020linear} does not satisfy the proof of knowledge property. Moreover, constructions with higher dimensions require more rounds and oracles which incur higher overhead in the distributed proof generation. Ligero++~\cite{ligero++} overcomes Ligero's $O(\sqrt{N})$ proof size bottleneck by using Virgo~\cite{Virgo} inner product argument, which uses Aurora style proof system. Thus the distributed proof generation of Ligero++ is similar to the distributed variant of Aurora. In our construction, we use inner product argument from Bulletproofs. In Table ~\ref{tab:SPZK}, we compare the different metrics of efficiency for all the existing $\DPZK$ protocols. }
%

\ADDED{Another recent line of works such as Wolverine~\cite{wolverine}, Mac'n'Cheese~\cite{macncheese}, LPZK~\cite{LPZK}, QuickSilver~\cite{quicksilver} focuses on the scalability of the zero-knowledge proofs. These works take the ``gate-by-gate'' paradigm by relying on Vector Oblivious Linear Evaluations (VOLEs). Wolverine provides a ZK protocol with $4$ field elements per multiplication gate. Mac'n'Cheese further improves it by providing a protocol with $3$ elements per multiplication gate. While QuickSilver and LPZK both achieve a ZK protocol with $1$ element per multiplication gate, LPZK is computationally heavier. All these works have linear communication complexity. Additionally, if the circuit satisfies a certain condition, called ``weak notion of uniformity'', QuickSilver achieves sub-linear communication. The gate-by-gate paradigm employed in these works, however, is restricted to interactive protocols. That is, it does not support non-interactiveness.
Furthermore, a common aggregator approach does not work for these protocols since this would either require the verifier to communicate with all the provers or the aggregator to learn the whole witness. Overcoming the problems mentioned above and obtaining distributed variants of these works is an interesting area to explore, which we leave as future work. }

%This is achieved by using Vector Oblivious Linear Evaluations (VOLEs). The main motive is to get the scalability of the ZK proofs.  \commentA{the sentence needs to be rewritten}Wolverine requires 4 field elements per multiplication gate, Mac'n'Cheese requires 3, LPZK requires 1 with high computational cost,  \commentA{it is not clear which one you refer to;  mal-formed sentence}which makes it impractical. \commentA{this sentence also does not make any sense} QuickSilver retains 1 with maintaining its practicability. Almost all of these works have linear communication complexity. QuickSilver claims to achieve sub-linear communication complexity for the circuits that satisfy a weak notion of uniformity.  \commentA{alert: rewrite }However, due to the use VOLEs, these schemes are restricted to interactive protocols. Furthermore, a common aggregator approach does not work for these line of works. Since these works provide a scalable zero-knowledge proof system, it will be very interesting to achieve distributed proof generation for these protocols,  \commentA{this is informal english} we'll leave it as future work.{}

\begin{table*}[htp] 
	\centering
	\resizebox{\textwidth}{!}{
		%\begin{threeparttable}
		\begin{tabular}{|c|c|c|c|c|c|c|} 
			\hline
			Protocols &  $\zkcomm$ & $\zkrounds$ & $t_\prover$ & $t_\verifier$ & $\prrounds$ & $\prcomm$ \\
			\hline
			\ADDED{D-Ligero} & \ADDED{$O(\sqrt{N})$} & \ADDED{$O(\log (N))$} & \ADDED{$O(\frac{N}{\log(N)})E + O(N\log(N))M$} & \ADDED{$O(\sqrt{N})E + O(N)M$} & \ADDED{1} & \ADDED{$O(\Num\cdot \sqrt{N} + \Num^2\cdot \max(N_s,\sqrt{N}))$}\\
			\hline
			\ADDED{D-Ligero++} & \ADDED{$O(\log^2{(N)})$} & \ADDED{$O(\log (N))$} & \ADDED{$O(N\log(N)) E+ O(N\log (N))M$} & \ADDED{$O(N\log (N))E+ O(N)M$} & \ADDED{$\log (N)$} & \ADDED{$O((\Num\cdot N + \Num^2\cdot N)\log (N))$}\\
			\hline
			\ADDED{D-Aurora} & \ADDED{$O(\log^2{(N)})$} & \ADDED{$O(\log (N))$} & \ADDED{$O(N\log (N)) E+ O(N\log (N))M$} & \ADDED{$O(N\log(N))E+ O(N)M$} & \ADDED{$\log (N)$} & \ADDED{$O((\Num\cdot N + \Num^2\cdot N)\log (N))$}\\
			\hline
			D-Bulletproofs & $O(\log (N))$ & $O(\log(N))$ & $O(N)E$ & $O(N)E$ & 1 & $ O(\Num\cdot N + \Num^2\cdot N_s)$ \\
			\hline
			\dpname & $O(N^{1/c})$ & $O(\log(N))$ & $O(\frac{N}{\log(N)})E + O(N\log(N))M$ & $O(N^{1-2/c})E + O(N)M$ & 1 & $ O(\Num\cdot N^{1-2/c} + \Num^2\cdot \max(N_s,N^{1-2/c}))$ \\
			\hline
			%&computation & communi- cation & MPC rounds& & & \\ 
			\hline
			%\hline
			%Bulletproofs & $O(nE+q(n+m)M)$ & $O(2N-1)$ & $O(\log n)$& $O(nE+$ $q(n+m)M)$ & $O(\log n)$ & $O(\log n)$  \\
			%\hline
			%Spartan & & & & & &\\
			%\hline
			%Aurora & & & & & &\\
			%\hline
			%\name2D & $O(n \log n)M$  $+nE)$ & $O(2N-1)$ & 1 &$O((nM +$ $ n^{1-1/c}E))$ & $O(n^{1/c})$ & $O(\log n)$ \\
			%\hline
			%\name3D & $O(nM+nE)$ & $O(2N-1)$& 1 & $O(nM+$ $n^{1-2/c}E)$ & $O(n^{1/c})$ & $O(\log n) $\\
			%\hline
		\end{tabular}
		%\end{threeparttable}
	}
	\caption{Comparison amongst the $\DPZK$s. Here $N$ is the size of the circuit and, $c$ is a positive integer of our choice. $\Num$ is the number provers in the $\DPZK$ setting. $M$ is to indicate the amount of computation required for a single multiplication on the field elements, and $E$ is to indicate the amount of computation required for single exponentiation on the group elements, in which $\mathsf{Dlog}$ is assumed to be hard. And $N_s$ denotes the size of the shared circuit.}\label{tab:SPZK}
	%\pnote{Con}
\end{table*}
